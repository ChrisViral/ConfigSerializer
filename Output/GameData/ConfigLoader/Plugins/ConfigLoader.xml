<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ConfigLoader</name>
    </assembly>
    <members>
        <member name="T:ConfigLoader.Attributes.ConfigFieldAttribute">
            <summary>
            Attribute used to mark fields and properties that can be loaded via ConfigObject
            </summary>
        </member>
        <member name="P:ConfigLoader.Attributes.ConfigFieldAttribute.Name">
            <summary>
            The name of the field in the config, if left blank, the name of the code field is used
            </summary>
        </member>
        <member name="P:ConfigLoader.Attributes.ConfigFieldAttribute.Required">
            <summary>
            If this config field is required to exist during deserialization
            </summary>
        </member>
        <member name="P:ConfigLoader.Attributes.ConfigFieldAttribute.ArrayHandling">
            <summary>
            How loading of array values is handled, defaults to <see cref="F:ConfigLoader.ArrayHandling.SINGLE_VALUE"/>;
            </summary>
        </member>
        <member name="P:ConfigLoader.Attributes.ConfigFieldAttribute.ArraySeparator">
            <summary>
            Separator string for array types
            </summary>
        </member>
        <member name="T:ConfigLoader.Attributes.ConfigParserAttribute">
            <summary>
            Config parser attribute
            </summary>
        </member>
        <member name="M:ConfigLoader.Attributes.ConfigParserAttribute.#ctor(System.Type)">
            <summary>
            Config parser attribute
            </summary>
        </member>
        <member name="P:ConfigLoader.Attributes.ConfigParserAttribute.TargetType">
            <summary>
            Type targeted by this parser
            </summary>
        </member>
        <member name="P:ConfigLoader.Attributes.ConfigParserAttribute.Priority">
            <summary>
            Parser priority
            </summary>
        </member>
        <member name="T:ConfigLoader.ConfigObject">
            <summary>
            Base class for auto-serializing <see cref="T:IConfigNode"/> implementations
            </summary>
        </member>
        <member name="M:ConfigLoader.ConfigObject.Load(ConfigNode)">
            <summary>
            Loads the object from the given node
            </summary>
            <param name="node">Node to load from</param>
        </member>
        <member name="M:ConfigLoader.ConfigObject.Save(ConfigNode)">
            <summary>
            Saves the object to the given node
            </summary>
            <param name="node">Node to save to</param>
        </member>
        <member name="M:ConfigLoader.Extensions.ConfigNodeExtensions.TryGetNode(ConfigNode,System.String,ConfigNode@)">
            <summary>
            Tries to get a named ConfigNode from the given ConfigNode
            </summary>
            <param name="node">Node to get the child node from</param>
            <param name="name">Name of the node find</param>
            <param name="result">Resulting node</param>
            <returns>True if the node has been found, false otherwise</returns>
        </member>
        <member name="M:ConfigLoader.Extensions.ConfigNodeExtensions.TryGetValue(ConfigNode,System.String,System.String@)">
            <summary>
            Tries to get a string value from the given ConfigNode
            </summary>
            <param name="node">Node to get the value from</param>
            <param name="name">Name of the value find</param>
            <param name="result">Resulting string value</param>
            <returns>True if the value has been found, false otherwise</returns>
        </member>
        <member name="M:ConfigLoader.Extensions.ConfigNodeExtensions.TryGetValue(ConfigNode,System.String,System.Int32@)">
            <summary>
            Tries to get an int value from the given ConfigNode
            </summary>
            <param name="node">Node to get the value from</param>
            <param name="name">Name of the value find</param>
            <param name="result">Resulting int value</param>
            <returns>True if the value has been found, false otherwise</returns>
        </member>
        <member name="M:ConfigLoader.Extensions.ConfigNodeExtensions.TryGetValue(ConfigNode,System.String,System.Single@)">
            <summary>
            Tries to get a float value from the given ConfigNode
            </summary>
            <param name="node">Node to get the value from</param>
            <param name="name">Name of the value find</param>
            <param name="result">Resulting float value</param>
            <returns>True if the value has been found, false otherwise</returns>
        </member>
        <member name="M:ConfigLoader.Extensions.ConfigNodeExtensions.TryGetValue(ConfigNode,System.String,System.Double@)">
            <summary>
            Tries to get a double value from the given ConfigNode
            </summary>
            <param name="node">Node to get the value from</param>
            <param name="name">Name of the value find</param>
            <param name="result">Resulting double value</param>
            <returns>True if the value has been found, false otherwise</returns>
        </member>
        <member name="M:ConfigLoader.Extensions.ConfigNodeExtensions.TryGetValue(ConfigNode,System.String,System.Boolean@)">
            <summary>
            Tries to get a bool value from the given ConfigNode
            </summary>
            <param name="node">Node to get the value from</param>
            <param name="name">Name of the value find</param>
            <param name="result">Resulting bool value</param>
            <returns>True if the value has been found, false otherwise</returns>
        </member>
        <member name="M:ConfigLoader.Extensions.ConfigNodeExtensions.TryGetValue(ConfigNode,System.String,UnityEngine.Vector3@)">
            <summary>
            Tries to get a Vector3 value from the given ConfigNode
            </summary>
            <param name="node">Node to get the value from</param>
            <param name="name">Name of the value find</param>
            <param name="result">Resulting Vector3 value</param>
            <returns>True if the value has been found, false otherwise</returns>
        </member>
        <member name="M:ConfigLoader.Extensions.DictionaryExtensions.Deconstruct``2(System.Collections.Generic.KeyValuePair{``0,``1},``0@,``1@)">
            <summary>
            Tuple deconstruction of a KeyValuePair
            </summary>
            <typeparam name="TKey">Key type</typeparam>
            <typeparam name="TValue">Value type</typeparam>
            <param name="pair">Pair to deconstruct</param>
            <param name="key">Key output value</param>
            <param name="value">Value output value</param>
        </member>
        <member name="M:ConfigLoader.Extensions.LoggingExtensions.Log(UnityEngine.Object,System.Object)">
            <summary>
            Logs the given message
            </summary>
            <param name="obj">Logging object</param>
            <param name="message">Message to log</param>
        </member>
        <member name="M:ConfigLoader.Extensions.LoggingExtensions.LogWarning(UnityEngine.Object,System.Object)">
            <summary>
            Logs the given warning
            </summary>
            <param name="obj">Logging object</param>
            <param name="message">Warning to log</param>
        </member>
        <member name="M:ConfigLoader.Extensions.LoggingExtensions.LogError(UnityEngine.Object,System.Object)">
            <summary>
            Logs the given error
            </summary>
            <param name="obj">Logging object</param>
            <param name="message">Error to log</param>
        </member>
        <member name="M:ConfigLoader.Extensions.LoggingExtensions.LogException(UnityEngine.Object,System.Object,System.Exception)">
            <summary>
            Logs the given exception
            </summary>
            <param name="obj">Logging object</param>
            <param name="message">Error message to log</param>
            <param name="e">Exception to log</param>
        </member>
        <member name="M:ConfigLoader.Extensions.LoggingExtensions.Log``1(``0,System.Object)">
            <summary>
            Logs the given message
            </summary>
            <param name="obj">Logging object</param>
            <param name="message">Message to log</param>
        </member>
        <member name="M:ConfigLoader.Extensions.LoggingExtensions.LogWarning``1(``0,System.Object)">
            <summary>
            Logs the given warning
            </summary>
            <param name="obj">Logging object</param>
            <param name="message">Warning to log</param>
        </member>
        <member name="M:ConfigLoader.Extensions.LoggingExtensions.LogError``1(``0,System.Object)">
            <summary>
            Logs the given error
            </summary>
            <param name="obj">Logging object</param>
            <param name="message">Error to log</param>
        </member>
        <member name="M:ConfigLoader.Extensions.LoggingExtensions.LogException``1(``0,System.Object,System.Exception)">
            <summary>
            Logs the given exception
            </summary>
            <param name="obj">Logging object</param>
            <param name="message">Error message to log</param>
            <param name="e">Exception to log</param>
        </member>
        <member name="T:ConfigLoader.ISerializableConfig">
            <summary>
            Autoloading Config Object interface
            </summary>
        </member>
        <member name="T:ConfigLoader.ConfigSerializer">
            <summary>
            Config object serializer
            </summary>
        </member>
        <member name="T:ConfigLoader.ConfigSerializer.SerializableMembers`1">
            <summary>
            Serializable member cache
            </summary>
            <typeparam name="T">Type of element to serialize</typeparam>
        </member>
        <member name="P:ConfigLoader.ConfigSerializer.SerializableMembers`1.Members">
            <summary>
            Serializable members for this type
            </summary>
            ReSharper disable once StaticMemberInGenericType
        </member>
        <member name="M:ConfigLoader.ConfigSerializer.SerializableMembers`1.FilterConfigMembers(System.Reflection.MemberInfo,System.Object)">
            <summary>
            FindMember filter that ensures the members are valid and instantiatable
            </summary>
            <param name="member">Member to test</param>
            <param name="criteria">Test criteria (unused)</param>
            <returns><see langword="true"/> if the member is valid, <see langword="false"/> otherwise</returns>
        </member>
        <member name="F:ConfigLoader.ConfigSerializer.CollectionAddParameters">
            <summary>
            ICollection Add reflection parameter buffer
            </summary>
        </member>
        <member name="M:ConfigLoader.ConfigSerializer.Serialize``1(System.String,``0,System.Nullable{ConfigLoader.ConfigSerializerSettings}@)">
            <summary>
            Serializes the object to a <see cref="T:ConfigNode"/> and returns it
            </summary>
            <typeparam name="T">Type of object to Serialize</typeparam>
            <param name="nodeName">Name of the ConfigNode to serialize it to</param>
            <param name="instance">Object to serialize</param>
            <param name="serializerSettings">Serializer settings, leave blank to use default settings</param>
            <returns>The serialized ConfigNode version of <paramref name="instance"/></returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="nodeName"/> or <paramref name="instance"/> is <see langword="null"/></exception>
        </member>
        <member name="M:ConfigLoader.ConfigSerializer.Serialize``1(ConfigNode,``0,System.Nullable{ConfigLoader.ConfigSerializerSettings}@)">
            <summary>
            Serializes the object to an existing <see cref="T:ConfigNode"/>
            </summary>
            <typeparam name="T">Type of object to Serialize</typeparam>
            <param name="node">ConfigNode to save the object to</param>
            <param name="instance">Object to serialize</param>
            <param name="serializerSettings">Serializer settings, leave blank to use default settings</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="node"/> or <paramref name="instance"/> is <see langword="null"/></exception>
        </member>
        <member name="M:ConfigLoader.ConfigSerializer.Deserialize``1(ConfigNode,System.Nullable{ConfigLoader.ConfigSerializerSettings}@)">
            <summary>
            Creates a new instance and deserializes to config data into it
            </summary>
            <typeparam name="T">Config type to deserialize</typeparam>
            <param name="node">Source node to deserialize from</param>
            <param name="serializerSettings">Serializer settings, leave blank to use default settings</param>
            <returns>The deserialized value</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="node"/> is <see langword="null"/></exception>
        </member>
        <member name="M:ConfigLoader.ConfigSerializer.Deserialize``1(ConfigNode,``0,System.Nullable{ConfigLoader.ConfigSerializerSettings}@)">
            <summary>
            Deserializes the given config using the passed defaults
            </summary>
            <typeparam name="T">Config type to deserialize</typeparam>
            <param name="node">Source node to deserialize from</param>
            <param name="defaults">Value to get defaults for each fields from (will be modified if a reference type)</param>
            <param name="serializerSettings">Serializer settings, leave blank to use default settings</param>
            <returns>The deserialized value into <paramref name="defaults"/>, if it is a reference type, the original reference is returned</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="node"/> or <paramref name="defaults"/> is <see langword="null"/></exception>
        </member>
        <member name="M:ConfigLoader.ConfigSerializer.Deserialize``1(ConfigNode,``0@,System.Nullable{ConfigLoader.ConfigSerializerSettings}@)">
            <summary>
            Deserializes the given config into the passed instance
            </summary>
            <typeparam name="T">Config type to deserialize</typeparam>
            <param name="node">Source node to deserialize from</param>
            <param name="instance">Value to deserialize into</param>
            <param name="serializerSettings">Serializer settings, leave blank to use default settings</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="node"/> or <paramref name="instance"/> is <see langword="null"/></exception>
        </member>
        <member name="T:ConfigLoader.MissingConfigFieldException">
            <summary>
            Exception thrown when a config field is expected but not found
            </summary>
        </member>
        <member name="M:ConfigLoader.MissingConfigFieldException.#ctor">
            <summary>
            Creates a new <see cref="T:ConfigLoader.MissingConfigFieldException"/>
            </summary>
        </member>
        <member name="M:ConfigLoader.MissingConfigFieldException.#ctor(System.String)">
            <summary>
            Creates a new <see cref="T:ConfigLoader.MissingConfigFieldException"/> with the given message
            </summary>
            <param name="message">Exception message</param>
        </member>
        <member name="M:ConfigLoader.MissingConfigFieldException.#ctor(System.String,System.String)">
            <summary>
            Creates a new <see cref="T:ConfigLoader.MissingConfigFieldException"/> with the given message and missing field name
            </summary>
            <param name="message">Exception message</param>
            <param name="fieldName">Name of the missing field</param>
        </member>
        <member name="T:ConfigLoader.Parsers.IConfigParserBase">
            <summary>
            Config Parser base
            </summary>
        </member>
        <member name="T:ConfigLoader.Parsers.IConfigParserBase`1">
            <summary>
            Config Parser generic base
            </summary>
            <typeparam name="T">Type of object being parsed</typeparam>
        </member>
        <member name="T:ConfigLoader.Parsers.ParserDatabase">
            <summary>
            Parser objects database
            </summary>
        </member>
        <member name="P:ConfigLoader.Parsers.ParserDatabase.Instance">
            <summary>
            ParserDatabase instance
            </summary>
        </member>
        <member name="P:ConfigLoader.Parsers.ParserDatabase.ValueParsers">
            <summary>
            ConfigNode value parsers
            </summary>
        </member>
        <member name="P:ConfigLoader.Parsers.ParserDatabase.NodeParsers">
            <summary>
            ConfigNode node parsers
            </summary>
        </member>
        <member name="T:ConfigLoader.Parsers.ParserFilter`1">
            <summary>
            Parser type filter
            </summary>
            <typeparam name="TParser">Parser type</typeparam>
        </member>
        <member name="T:ConfigLoader.Parsers.ParserFilter`1.ParserData">
            <summary>
            Parser data
            </summary>
            <param name="Parser">Parser instance</param>
            <param name="Attribute">Parser attribute</param>
        </member>
        <member name="M:ConfigLoader.Parsers.ParserFilter`1.ParserData.#ctor(`0,ConfigLoader.Attributes.ConfigParserAttribute)">
            <summary>
            Parser data
            </summary>
            <param name="Parser">Parser instance</param>
            <param name="Attribute">Parser attribute</param>
        </member>
        <member name="P:ConfigLoader.Parsers.ParserFilter`1.ParserData.Parser">
            <summary>Parser instance</summary>
        </member>
        <member name="P:ConfigLoader.Parsers.ParserFilter`1.ParserData.Attribute">
            <summary>Parser attribute</summary>
        </member>
        <member name="P:ConfigLoader.Parsers.ParserFilter`1.ParsersByType">
            <summary>
            Parsers keyed by parser type
            </summary>
        </member>
        <member name="P:ConfigLoader.Parsers.ParserFilter`1.ParsersByTargetType">
            <summary>
            Parsers keyed by target type
            </summary>
        </member>
        <member name="M:ConfigLoader.Parsers.ParserFilter`1.#ctor(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Creates a new ParserFilter from a set of valid types based on the parser subtype
            </summary>
            <param name="parserTypes">Enumerable of valid parser types</param>
        </member>
        <member name="M:ConfigLoader.Parsers.ParserFilter`1.TryGetParserByType(System.Type,`0@)">
            <summary>
            Tries to get a parser for the given parser type
            </summary>
            <param name="parserType">Parser type to find</param>
            <param name="parser">Found parser instance, uninitialized if no match found</param>
            <returns><see langword="true"/> if a valid parser has been found, otherwise <see langword="false"/></returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="parserType"/> is <see langword="null"/></exception>
        </member>
        <member name="M:ConfigLoader.Parsers.ParserFilter`1.TryFindBestParserForType(System.Type,`0@)">
            <summary>
            Tries to find the best parser for a given target type
            </summary>
            <param name="targetType">Target type to parse to</param>
            <param name="parser">Found parser instance, uninitialized if no match found</param>
            <returns><see langword="true"/> if a valid parser has been found, otherwise <see langword="false"/></returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="targetType"/> is <see langword="null"/></exception>
        </member>
        <member name="T:ConfigLoader.Utils">
            <summary>
            Collection of utility methods
            </summary>
        </member>
        <member name="M:ConfigLoader.Utils.ParseArray(System.String)">
            <summary>
            Parses a comma separated string line to a string array. Entries are space trimmed and never empty
            </summary>
            <param name="text">Text to parse</param>
            <returns>The resulting string non-empty string array</returns>
        </member>
        <member name="M:ConfigLoader.Utils.ParseArray(System.String,System.Char[])">
            <summary>
            Parses a string line with given delimiter to a string array. Entries are space trimmed and are never empty
            </summary>
            <param name="text">Text to parse</param>
            <param name="delimiters">Char delimiters to separate the array</param>
            <returns>The resulting string non-empty string array</returns>
        </member>
        <member name="M:ConfigLoader.Utils.ParseArray(System.String,System.String[])">
            <summary>
            Parses a string line with given delimiter to a string array. Entries are space trimmed and are never empty
            </summary>
            <param name="text">Text to parse</param>
            <param name="delimiters">Char delimiters to separate the array</param>
            <returns>The resulting string non-empty string array</returns>
        </member>
        <member name="M:ConfigLoader.Utils.LogException(System.String,System.Object,System.Exception)">
            <summary>
            Logs the given exception
            </summary>
            <param name="header">Log header</param>
            <param name="message">Error message to log</param>
            <param name="e">Exception to log</param>
        </member>
        <member name="T:System.Runtime.CompilerServices.IsExternalInit">
            <summary>
                Reserved to be used by the compiler for tracking metadata.
                This class should not be used by developers in source code.
            </summary>
            <remarks>
                This definition is provided by the <i>IsExternalInit</i> NuGet package (https://www.nuget.org/packages/IsExternalInit).
                Please see https://github.com/manuelroemer/IsExternalInit for more information.
            </remarks>
        </member>
    </members>
</doc>
